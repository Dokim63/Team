package com.javalab.sec02;

public class SelectionSort {
    //메서드
    public static void main(String[] args) {
        //정수 배열을 선언하고 초기화합니다.
        int[] arr = {64, 25, 12, 22, 11};

        //배열의 요소를 반복
        for (int i = 0; i < arr.length - 1; i++) {
            //min_idx 변수를 현재 인덱스 i로 초기화. 이 변수는 각 단계에서 찾은 최소 요소의 인덱스를 추적합니다.
            int min_idx = i;
            //배열의 나머지 정렬되지 않은 부분을 반복하는 또 다른 루프를 시작.
            // 이 루프는 i 다음 인덱스부터 시작하여 나머지 부분에서 최소 요소를 찾습니다.
            for (int j = i + 1; j < arr.length; j++) {
                // 인덱스 j의 요소가 현재 최소 요소(arr[min_idx])보다 작은지 확인.
                //그렇다면, min_idx를 j로 업데이트하여 arr[j]가 새로운 최소 요소임을 나타냅니다.
                if (arr[j] < arr[min_idx]) {
                    min_idx = j;
                }
            }
            //이 코드는 필요한 경우 인덱스 i와 min_idx의 요소를 교환합니다.
            //이로써 현재 단계에서 찾은 최소 요소를 정렬된 부분의 올바른 위치에 놓게 됩니다.
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
        //선택 정렬 알고리즘을 사용하여 배열을 정렬한 후 정렬된 배열을 출력합니다.
        System.out.print("Sorted array: ");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

/**
 * 코딩에서 선택 정렬은 다음과 같은 여러 방법으로 도움이 될 수 있습니다:
 * 교육 목적: 간결성 때문에 선택 정렬은 정렬 알고리즘의 개념을 소개하는 데 자주 사용됩니다.
 * 간결성: 선택 정렬은 이해하고 구현하기 쉬우므로 빠르고 간단한 해결책이 필요한 상황에 적합합니다.
 * 작은 데이터 집합: 작은 데이터 집합의 경우 선택 정렬은 충분히 효율적일 수 있으며 간결성과 오버헤드가 적기 때문에 더 복잡한 알고리즘보다 성능이 우수할 수 있습니다.
 * 전반적으로 선택 정렬은 대규모 데이터 집합에 대해 가장 효율적인 정렬 알고리즘이 아닐 수 있지만 간결성과 구현의 용이성이 성능 최적화보다 중요한 경우에는 여전히 유용할 수 있습니다.
 */

/**
 * 요약하면, main 함수는 선택 정렬 알고리즘을 사용하여 정수 배열을 오름차순으로 정렬합니다.
 * 이 코드는 정렬되지 않은 부분에서 최소 요소를 반복적으로 선택하고 정렬된 부분의 올바른 위치에 놓는 과정을 반복합니다.
 * 이 구현은 작은 배열에 대해서는 간단하고 효율적이지만, 큰 데이터셋에 대해서는 이차 시간 복잡도 때문에 적합하지 않을 수 있습니다.
 */
